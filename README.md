![image](https://github.com/user-attachments/assets/a2e87247-6572-4fd3-a3a3-697b0a15c3bd)Algorytm genetyczny to metoda optymalizacyjna inspirowana mechanizmami biologicznej ewolucji. Jej główna idea polega na ewolucji populacji potencjalnych rozwiązań poprzez symulację procesu doboru naturalnego. W kontekście problemu komiwojażera, każde rozwiązanie, zwane osobnikiem, reprezentuje możliwą trasę odwiedzenia wszystkich miast, zapisaną jako permutacja liczb od 1 do n, gdzie n to liczba punktów do odwiedzenia.
Proces działania rozpoczyna się od utworzenia początkowej populacji osobników (80). Każdy osobnik jest generowany losowo, jako unikalna permutacja odwiedzin miast. Po wygenerowaniu populacji następuje etap oceny dopasowania, który polega na obliczeniu długości trasy dla każdego osobnika. W tym celu wykorzystuje się funkcję calculate_distance, która korzysta z wcześniej przygotowanej macierzy odległości pomiędzy wszystkimi parami miast. Funkcja sumuje odległości pomiędzy kolejnymi miastami w trasie i dodaje koszt powrotu z ostatniego miasta do pierwszego, zamykając pętlę. Na tej podstawie wyliczane jest dopasowanie (fitness), które w implementacji przyjmuje postać odwrotności długości trasy – im krótsza trasa, tym wyższe dopasowanie. Taka konstrukcja zapewnia, że algorytm preferuje osobniki, które reprezentują bardziej optymalne rozwiązania.
W kolejnym etapie odbywa się selekcja osobników, które zostaną wykorzystane jako rodzice do utworzenia nowego pokolenia. W tym celu zastosowano selekcję turniejową o rozmiarze 3. W każdej selekcji losowanych jest trzech osobników z bieżącej populacji, a do dalszego etapu wybierany jest ten, którego trasa ma najniższy koszt.  
Po wybraniu par rodziców następuje krzyżowanie, którego celem jest wygenerowanie potomków łączących cechy obu rodziców. W implementacji zastosowano operator Order Crossover. Losowo wybierany jest fragment trasy z pierwszego rodzica, który zostaje bezpośrednio skopiowany do potomka. Następnie pozostałe pozycje wypełniane są elementami z drugiego rodzica w kolejności ich występowania, z pominięciem już użytych miast. Dzięki temu uzyskiwana jest pełna, poprawna permutacja. Taki sposób działania umożliwia zachowanie części struktury trasy (czyli kolejności odwiedzin) z jednego rodzica oraz jej uzupełnienie o elementy drugiego, co zwiększa szansę na dziedziczenie korzystnych fragmentów rozwiązań.
Każdy nowo utworzony potomek może podlegać mutacji – czyli losowej zamianie miejsc dwóch miast w trasie. W implementacji prawdopodobieństwo mutacji wynosi 10%. Mutacja umożliwia wprowadzenie dodatkowej różnorodności do populacji i pozwala na ucieczkę z lokalnych minimów, które mogłyby zatrzymać proces optymalizacji w miejscu. 
Aby zapobiec sytuacji, w której bardzo dobre rozwiązania zostałyby przypadkowo utracone, w algorytmie zastosowano mechanizm elityzmu. Polega on na tym, że dwa najlepsze osobniki z bieżącej populacji są bez zmian przenoszone do kolejnego pokolenia. Dzięki temu algorytm nie traci osiągniętego postępu i może go wykorzystać w kolejnych iteracjach. 
W implementacji zdecydowałam się na 400 iteracji, co okazało się wystarczające do osiągnięcia stabilnej zbieżności w większości przypadków testowych.
